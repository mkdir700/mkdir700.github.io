<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二分查找模板</title>
      <link href="/2020/07/12/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/07/12/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>最近又开始刷算法题，准备在这个暑假把算法练练。</p><p>本文模板均来自leetcode</p><p><a href="https://leetcode-cn.com/explore/learn/card/binary-search/" target="_blank" rel="noopener">https://leetcode-cn.com/explore/learn/card/binary-search/</a></p><h2 id="二分查找模板-1"><a href="#二分查找模板-1" class="headerlink" title="二分查找模板 #1"></a>二分查找模板 #1</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">def binarySearch(nums, target):    &quot;&quot;&quot;    :type nums: List[int]    :type target: int    :rtype: int    &quot;&quot;&quot;    if len(nums) == 0:        return -1    left, right = 0, len(nums) - 1    while left &lt;= right:        mid = (left + right) // 2        if nums[mid] == target:            return mid        elif nums[mid] &lt; target:            left = mid + 1        else:            right = mid - 1    # End Condition: left &gt; right    return -1</code></pre><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><blockquote><p>用于查找可以通过<em>访问数组中的单个索引</em>来确定的元素或条件。</p></blockquote><h2 id="二分查找模板-2"><a href="#二分查找模板-2" class="headerlink" title="二分查找模板 #2"></a>二分查找模板 #2</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">def binarySearch(nums, target):    &quot;&quot;&quot;    :type nums: List[int]    :type target: int    :rtype: int    &quot;&quot;&quot;    if len(nums) == 0:        return -1    left, right = 0, len(nums) # 注意right = len(nums)    while left &lt; right:        mid = (left + right) // 2        if nums[mid] == target:            return mid        elif nums[mid] &lt; target:            left = mid + 1        else:            right = mid    # Post-processing:    # End Condition: left == right    if left != len(nums) and nums[left] == target:        return left    return -1</code></pre><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><blockquote><p>模板 #2 是二分查找的高级模板。它用于查找需要<em>访问数组中*</em>当前索引及其直接右邻居索引***的元素或条件。</p></blockquote><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h4><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给定一个输入数组 <code>nums</code>，其中 <code>nums[i] ≠ nums[i+1]</code>，找到峰值元素并返回其索引。</p><p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code>。</p><p><strong>示例 1:</strong></p><pre><code>输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2；     或者返回索引 5， 其峰值元素为 6。</code></pre><p><strong>说明:</strong></p><p>你的解法应该是 <em>O</em>(<em>logN</em>) 时间复杂度的。</p><h2 id="二分查找模板-3"><a href="#二分查找模板-3" class="headerlink" title="二分查找模板 #3"></a>二分查找模板 #3</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">def binarySearch(nums, target):    &quot;&quot;&quot;    :type nums: List[int]    :type target: int    :rtype: int    &quot;&quot;&quot;    if len(nums) == 0:        return -1    left, right = 0, len(nums) - 1    while left + 1 &lt; right:        mid = (left + right) // 2        if nums[mid] == target:            return mid        elif nums[mid] &lt; target:            left = mid        else:            right = mid    # Post-processing:    # End Condition: left + 1 == right    if nums[left] == target: return left    if nums[right] == target: return right    return -1</code></pre><h3 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h3><blockquote><p>模板 #3 是二分查找的另一种独特形式。 它用于搜索需要<em>访问当前索引及其在数组中的直接左右邻居索引</em>的元素或条件。</p></blockquote><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3>]]></content>
      
      
      <categories>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>658.找到K个最接近的元素</title>
      <link href="/2020/07/12/658.%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E6%95%B0/"/>
      <url>/2020/07/12/658.%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="找到K个最接近的元素"><a href="#找到K个最接近的元素" class="headerlink" title="找到K个最接近的元素"></a>找到K个最接近的元素</h1><p>给定一个排序好的数组，两个整数 <code>k</code> 和 <code>x</code>，从数组中找到最靠近 <code>x</code>（两数之差最小）的 <code>k</code> 个数。返回的结果必须要是按升序排好的。如果有两个数与 <code>x</code> 的差值一样，优先选择数值较小的那个数。</p><p><strong>示例 1:</strong></p><pre><code>输入: [1,2,3,4,5], k=4, x=3输出: [1,2,3,4]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [1,2,3,4,5], k=4, x=-1输出: [1,2,3,4]</code></pre><p><strong>说明:</strong></p><ol><li>k 的值为正数，且总是小于给定排序数组的长度。</li><li>数组不为空，且长度不超过 104</li><li>数组里的每个元素与 x 的绝对值不超过 104</li></ol><p><strong>更新(2017/9/19):</strong><br>这个参数 <em>arr</em> 已经被改变为一个<strong>整数数组</strong>（而不是整数列表）。 <strong>请重新加载代码定义以获取最新更改。</strong></p><hr><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本文参考这位大佬的题解[方法二： 二分查找最优区间的左边界]</p><p><a href="https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/</a></p><p>此问题转换为 <strong>查找最优区间的左边界</strong></p><pre><code>输入: [1,2,3,4,5], k=4, x=3输出: [1,2,3,4]</code></pre><p>例如这个示例，<strong>k为4</strong>，即区间的长度为4，这个区间可能是 <strong>[1,2,3,4] 和 [2,3,4,5]</strong>，所以最左边界元素的区间在 <strong>[0, 1]</strong>范围内</p><p>也就是说，<strong>最优区间的左边界</strong>在<strong>[0, length-k]</strong>这个区间中</p><p>那么，现在的问题就转换成了 在<strong>[0, length-k]</strong>区间内找到一个元素，这个元素是<strong>最优区间的左边界</strong></p><p>来整理一下题目的条件：</p><blockquote><p><strong>x</strong> ： 目标值</p><p><strong>k</strong> ： 结果数组内的元素个数</p></blockquote><ol><li>最优区间内的每个元素与 <strong>x</strong> 的差值都是最小的</li><li>找到的最优区间必须升序排列的</li></ol><h3 id="步骤解析"><a href="#步骤解析" class="headerlink" title="步骤解析"></a>步骤解析</h3><p>1.找到左边界元素所在区间</p><blockquote><p>这个很简单，就是[0, length-k]</p></blockquote><p>2.区间内的中位数(<strong>x - arr[mid]</strong>与<strong>arr[mid+k] - x</strong>进行比较)</p><blockquote><p>首先明白此时<strong>mid</strong>和<strong>mid+k</strong>各自代表的意义是什么？</p><p>mid：“最优区间”的左边界，可能当前不是最优区间，待进一步二分查找</p><p>mid+k：“最优区间”右边界的<strong>右边一位</strong></p><p>1) 如果<strong>x - arr[mid] &gt; arr[mid+k] - x</strong>,说明什么？</p><ul><li>说明 <strong>x</strong> 更应该靠近<strong>arr[mid+k]</strong>一些， 即<strong>arr[mid, mid+k]</strong>这个区间整体向右滑动，才可能成为 <strong>最优区间</strong></li><li>要使得这个区间<strong>向右滑动</strong>，也就是将这个区间的<strong>左边界右移</strong>。</li><li>回到二分查找，就是向右收缩 =&gt; <strong>left = mid + 1</strong></li></ul><p>2) 如果<strong>x - arr[mid] &lt; arr[mid+k] - x</strong>,说明什么？</p><ul><li>说明 <strong>mid + k位置 及 右边所有的元素</strong> 都不符合最优区间（因为是升序的），当前的“最优区间”为 arr[mid, mid + k]。但是mid之前可能存在有元素哦，所以mid之前的元素应该继续进行判断</li><li>mid之前的元素可能有更优的，就是区间<strong>可能向左移动</strong>，也可能当前mid就是最优区间的左边界（不移动）</li><li>为了找到更合适的mid，所以应该收缩[0, length-k]这个区间，因为是去找mid及mid之前的元素，所以是向左收缩，即 right = mid</li><li>为什么是right = mid，而不是right = mid - 1？因为mid这个位置的值，可能刚好就是<strong>最优区间的左边界</strong>，如果mid-1就错过了</li></ul><p>3) 如果<strong>x - arr[mid] = arr[mid+k] - x</strong>,说明什么？</p><ul><li>仔细想想，这两者差值相等的情况是和 <strong>2)</strong> 的情况一致</li></ul></blockquote><p>3.经过左右边界的不断收缩，最终找到的一个元素，这个元素就是 <strong>最优区间的左边界</strong>,即可求出答案</p><p><img src="https://s1.ax1x.com/2020/07/08/UVsOsg.gif" alt="程序执行动图"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="python">class Solution:    def findClosestElements(self, arr: List[int], k: int, x: int) -&gt; List[int]:        left, right = 0, len(arr) - k # 确定最优区间的左边界所在区间范围        while left &lt; right:            mid = (left + right) &gt;&gt; 1 # 找到中位数            if x - arr[mid] &gt; arr[mid+k] - x: # 比较差值，收缩区间                left = mid + 1            elif x - arr[mid] &lt;= arr[mid+k] - x:                right = mid        return arr[left:left+k]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>378.有序矩阵中第K小的元素</title>
      <link href="/2020/07/12/378.%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
      <url>/2020/07/12/378.%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。 </p><p>示例：</p><pre><code>matrix = [   [ 1,  5,  9],   [10, 11, 13],   [12, 13, 15]],k = 8,返回 13。</code></pre><p>提示：<br>你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><a id="more"></a><p>此笔记参考题解：</p><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/you-xu-ju-zhen-zhong-di-kxiao-de-yuan-su-by-leetco/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/you-xu-ju-zhen-zhong-di-kxiao-de-yuan-su-by-leetco/</a></p><h1 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h1><p>从左到右递增，从上往下递增，即<code>matrix[0][0]</code>是最小值，<code>matrix[n-1][n-1]</code>是最大值。我们所需找到的第Ｋ小元素必定在<code>[matrix[0][0], matrix[n-1][n-1]]</code>区间内。</p><p>至此，<strong>有序</strong>　＋　<strong>确定范围</strong>　可以使用<strong>二分查找</strong></p><p>让　<code>left = matrix[0][0]</code> <code>right = matrix[n-1][n-1]</code></p><p>则有 <code>mid = (left + right) &gt;&gt; 1</code></p><p>以下方这个矩阵举例</p><p><img src="/home/mk/Desktop/U1VQJJ.png" alt="U1VQJJ.png"></p><h2 id="分割矩阵"><a href="#分割矩阵" class="headerlink" title="分割矩阵"></a>分割矩阵</h2><p>第一次计算<code>mid = (1 + 16) &gt;&gt; 1 = 8</code></p><p>以<code>mid</code>为界，可以将整个矩阵分割成两个部分，那怎么分？</p><p>重要条件 <strong>每行和每列元素均按升序排序</strong></p><p>从左下角开始的元素开始，不断往右走，当元素小于或等于<code>mid</code>，则此元素及上方所有元素，均是比<code>mid</code>值小的元素。 文字表达不太清楚，看图比较直观。橙色部分都是<code>&lt;=mid</code>的元素</p><p><img src="https://s1.ax1x.com/2020/07/11/U1nOD1.png" alt="U1nOD1.png"></p><p>通过<code>mid</code>将矩阵一分为二，则需要我们判断<strong>第k小元素在哪一边</strong></p><blockquote><p>  这里和常规的二分查找类似，都需要依据mid来判定目标元素在左右的哪一边</p></blockquote><p>但这里又和二分查找又有点区别，就是我们<strong>拿什么与什么进行比较</strong></p><h2 id="确定查找范围"><a href="#确定查找范围" class="headerlink" title="确定查找范围"></a>确定查找范围</h2><p>第一，明白 <strong>寻找第k小元素</strong> 的区间内元素个数要求</p><p>举个例子：<code>1,2,3,4</code>，第3小的元素，那么是3；<code>1,2,2,3,4</code>，同样是第3小的，则是2</p><p>由此可知，要找到第k小元素，那么这个区间中至少至少得有k个元素吧！</p><p>第二， <code>mid</code>将矩阵分割成两部分，我们简单可以看成<strong>较小元素的部分</strong>和<strong>较大元素的部分</strong>，既然寻找第k<strong>小元素</strong>，结合第一个解释，所以，较小元素部分的元素个数应该是<strong>大于等于k的</strong></p><p>至此，我们知道是 <strong>num</strong>(元素较小部分的元素个数) 与 <strong>k</strong>之间的比较</p><h2 id="比较num与k"><a href="#比较num与k" class="headerlink" title="比较num与k"></a>比较num与k</h2><p>怎么个比较法？</p><p>如果 <strong>num &gt;= k</strong> ，说明 <strong>较小元素部分的范围太大了</strong> 需要缩小范围，即「边界收缩」</p><blockquote><p>   right = mid</p></blockquote><p>如果 <strong>num &lt; k</strong>，说明 <strong>较小元素部分的范围太小了</strong> 需要扩大范围</p><p>这里说明下，待查找范围的大小与<code>right</code>有关，而<code>left</code>的作用是查找元素。</p><p>即 <code>right</code>将一个大致的范围给定好，然后<code>left</code>在范围内「猜」元素</p><p><strong>直接限定</strong>范围大小的元素是<code>right</code>吗？不是，是<code>mid</code>。因为我们是以<code>mid</code>为中线，进行分割，所以想<strong>扩大范围</strong>，就是<strong>增大<code>mid</code>值</strong>，增大mid意味着增大<code>left</code>或<code>right</code></p><blockquote><p>  left = mid + 1</p></blockquote><p>经过 <code>while left &lt; right</code> 循环，最终跳出循环 <code>return left</code>，left即是答案</p><p><img src="http://cdn.z2blog.com/img/20200711232803.gif" alt="动图演示"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="python">class Solution:    def kthSmallest(self, matrix: List[List[int]], k: int) -&gt; int:        n = len(matrix)        def check(mid):            &quot;&quot;&quot;遍历获取较小元素部分元素总数，并与k值比较&quot;&quot;&quot;            i, j = n-1, 0            num = 0            while i &gt;= 0 and j &lt; n:                if matrix[i][j] &lt;= mid:                    # 当前元素小于mid，则此函数及上方函数均小于mid                    num += i + 1                    # 向右移动                    j += 1                else:                    # 当前元素大于mid，则向上移动，直到找到比mid小的值，或者出矩阵                    i -= 1            return num &gt;= k        left, right = matrix[0][0], matrix[-1][-1]        while left &lt; right:            mid = (left + right) &gt;&gt; 1            if check(mid):                # 满足 num &gt;= k，范围太大，移动right至mid， 范围收缩                right = mid            else:                left = mid + 1        return left</code></pre><h2 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h2><h3 id="为什么left就一定是在矩阵中呢？"><a href="#为什么left就一定是在矩阵中呢？" class="headerlink" title="为什么left就一定是在矩阵中呢？"></a>为什么left就一定是在矩阵中呢？</h3><blockquote><p>  <code>matrix[0][0]</code> 与 <code>matrix[n-1][n-1]</code>是存在矩阵中，而计算出来的<code>mid</code>，可能不在矩阵中，也就意味后续相关的<code>left</code>与<code>right</code>也可能不在矩阵中，那么为什么偏偏<code>left</code>就在矩阵中而且还是正确答案呢？</p></blockquote><p>先来看一个简单的矩阵示例：</p><p><img src="http://cdn.z2blog.com/img/20200711235324.png" alt=""></p><p><strong>要求：找到第2小的元素</strong></p><p>在这个矩阵中，第一次<code>mid</code>计算值为<code>50</code>（不在矩阵中），以<code>50</code>为分割，得到的<code>num</code>为<code>1</code></p><p>在循环中，<code>num</code> 一直小于<code>k</code>， 则<code>left</code> 一直在做 <code>mid + 1</code>，最终加到<code>80</code>的时候，mid = (80 + 100) / 2 = 90，至此使得<code>num</code>为<code>2</code>，此时<code>num=k</code>，即<code>right = mid = 90</code>，<code>left</code>继续做<code>mid+1</code>，当加到<code>90</code>时，left = right，退出循环，返回<code>left</code>，即90</p><p>通过这个简单的矩阵，就知道 第k小的值不是直接算出来的，而是「猜」出来的，二分查找就是在不断缩小范围并猜值</p><p>回到问题，为什么left就一定是在矩阵中呢？</p><p>上面的示例，退出循环时，必定有<code>left=right</code>，返回<code>left</code>即返回<code>right</code>，所以<code>right</code>的值是最终答案</p><p>好的，那么<code>right</code>的值怎么来滴，由<code>right=mid</code>可知，<code>mid</code>决定<code>right</code></p><p>所以，<code>mid</code>就是最终答案(有特例，比如<code>[[-5]]</code>)， 这里只是笼统的认为，方便理解</p><p>(left + right) / 2 决定了<code>mid</code>， left的变换是因为<code>num&lt;k</code></p><p><strong>因为<code>left</code>在不停的失错，直到使得mid的值，可以满足num&gt;=k</strong></p><p>这也说明了，此方法只适用于<strong>整数矩阵</strong>，如果是小数就不行了，因为每次试错的最小增量是<strong>1</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23.合并K个排序列表</title>
      <link href="/2020/07/12/23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8/"/>
      <url>/2020/07/12/23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例:</strong></p><p>输入:</p><pre><code>[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]</code></pre><p>输出: <strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</strong></p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists</a></p><p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>此学习笔记，参考题解：</p><p>感谢！！</p><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/duo-tu-yan-shi-23-he-bing-kge-pai-xu-lian-biao-by-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/duo-tu-yan-shi-23-he-bing-kge-pai-xu-lian-biao-by-/</a></p><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/leetcode-23-he-bing-kge-pai-xu-lian-biao-by-powcai/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/leetcode-23-he-bing-kge-pai-xu-lian-biao-by-powcai/</a></p><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><blockquote><p>  依靠最小堆的特性，每次弹出必定是最小值</p></blockquote><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>步骤：</p><ol><li>将所有节点的加入到堆队列中</li><li>不断弹出，生成新的链表</li></ol><blockquote><p>  说明： 在python中，实例与实例之间不能直接使用 <code>&gt;</code>等比较运算符</p><p>  我们可以写一个魔术方法，使得〔ListNode〕之间可以大小比较</p><pre><code class="python">  def __lt__(self, other):      return self.val &lt; other.val  ListNode.__lt__ = __lt__</code></pre></blockquote><p>完整代码：</p><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        if not lists: return None        import heapq        queue = []        dummy = ListNode(-1)        def __lt__(self, other):            return self.val &lt; other.val        ListNode.__lt__ = __lt__        cur = dummy        # 将所有节点加入至堆队列中        for l in lists:            while l:                heapq.heappush(queue, l)                l = l.next        # 不断取出节点        while queue:            # 由于最小堆的特性，每次取出的节点都是最小的            node = heapq.heappop(queue)            cur.next = node            cur = cur.next        cur.next = None        return dummy.next</code></pre><p>空间复杂度： O(N)</p><h4 id="堆排序优化"><a href="#堆排序优化" class="headerlink" title="堆排序优化"></a>堆排序优化</h4><p>此方法是对上一方法的优化，在上面方法中是直接将所有的节点一股脑全部丢到堆队列中，这造成了空间的浪费。在此，可以将空间复杂度优化成<code>O(K)</code>，即链表的数量</p><p><img src="https://pic.leetcode-cn.com/a91253f60b46b4d804adff9d3af7fb54586018e173d480cf06f4530630f3eb8d-3.jpg" alt="演示图"></p><p>将每个链表的头结点，加入到堆队列即可，<strong>当此节点出队列时，立即判断此节点的指针域是否为空，不为空就表示后面还有节点，所以将后面的节点加入到堆队列中</strong>。如此一来，堆队列的空间大小就没有发生变换。</p><p>步骤：</p><ol><li>将所有链表的头节点加入到堆队列中</li><li>出队，将出来的节点连接到新节点上<code>dummy</code></li><li>检测刚出队的节点的指针域是否有效，有效则将下一个节点加入到堆队列中</li></ol><p>完整代码：</p><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        def __lt__(self, other):            return self.val &lt; other.val        ListNode.__lt__ = __lt__        if not lists:            return        import heapq        queue = []        dummy = ListNode(-1)        cur  = dummy        # 将所有的链表的头结点入队        for i in range(len(lists)):            head = lists[i]            if head:                heapq.heappush(queue, head)        # 从堆队列中弹出并检测是否还有下一个节点，有则加入到堆队列中        while queue:            node = heapq.heappop(queue)            cur.next = node            cur = cur.next            # 下一个节点是否有效            if node.next:                heapq.heappush(queue, node.next)        cur.next = None        return dummy.next</code></pre><h3 id="两两合并"><a href="#两两合并" class="headerlink" title="两两合并"></a>两两合并</h3><p>[简单]合并两个有序链表：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><p>之前做过一道题，实现两个有序链表的合并</p><p>本题是多个有序链表的合并，所以自然可以使用使用两两合并，合并到最后即成为一个有序链表</p><p>完整代码：</p><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        dummy = ListNode(float(&#39;-inf&#39;))        cur = dummy        for i in range(len(lists)):            cur = self.mergeTwoLists(cur, lists[i])        return dummy.next    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        dummy = ListNode(-1)        cur = dummy        while l1 and l2:            if l1.val &lt; l2.val:                cur.next = l1                l1 = l1.next            else:                cur.next = l2                l2 = l2.next            cur = cur.next        cur.next = l1 if l1 else l2        return dummy.next</code></pre><p>然而，效率极低</p><p><img src="https://s1.ax1x.com/2020/07/10/UK53rQ.png" alt="UK53rQ.png"></p><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>在排序算法中，一个〔归并排序〕</p><blockquote><p>  将无序的序列分解成一个一个，然后按有序方式组合</p></blockquote><p>归并排序中的 <strong>分治思想</strong> 可以在此题应用到</p><p><img src="https://pic.leetcode-cn.com/88d261465f1f21288dd23cef2f059297f5d053fc19805458a47ae1b05f3c0703-6.jpg" alt="6.jpg"></p><p>按照归并排序的案例或上图的演示，我们首先将 <strong>lists</strong> 中的链表一分再分， 然后按照大小关系一一合并</p><p>步骤：</p><ol><li>将 <strong>lists</strong> 一分再分，分到不能再分为止</li><li>不断合并</li><li>最后得到完整的有序链表</li></ol><blockquote><p>  步骤描述只是大概，具体还是得根据代码来慢慢理解，所以一定要写注释！！！</p></blockquote><p>完整代码：</p><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        if not lists: return         return self.merge(0, len(lists)-1, lists)    def merge(self, left, right, lists):        &quot;&quot;&quot;将lists不断分割，这里的操作有点像二分法        通过不断的一分二，分到最小单位        &quot;&quot;&quot;        if left == right:            return lists[left]        mid = (left + right) &gt;&gt; 1        l1 = self.merge(left, mid, lists)        l2 = self.merge(mid+1, right, lists)        # 调用合并函数，将 l1 和 l2合并成新有序链表        return self.mergeTwoLists(l1, l2)    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        &quot;&quot;&quot;将两个链表合成一个有序链表&quot;&quot;&quot;        dummy = ListNode(-1)        cur = dummy        while l1 and l2:            if l1.val &lt; l2.val:                cur.next = l1                l1 = l1.next            else:                cur.next = l2                l2 = l2.next            cur = cur.next        cur.next = l1 if l1 else l2        return dummy.next</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
            <tag> 分治算法 </tag>
            
            <tag> 优先级队列 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
