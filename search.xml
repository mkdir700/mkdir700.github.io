<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>658.找到K个最接近的元素</title>
      <link href="/2020/07/10/658.%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E6%95%B0/"/>
      <url>/2020/07/10/658.%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="找到K个最接近的元素"><a href="#找到K个最接近的元素" class="headerlink" title="找到K个最接近的元素"></a>找到K个最接近的元素</h1><p>给定一个排序好的数组，两个整数 <code>k</code> 和 <code>x</code>，从数组中找到最靠近 <code>x</code>（两数之差最小）的 <code>k</code> 个数。返回的结果必须要是按升序排好的。如果有两个数与 <code>x</code> 的差值一样，优先选择数值较小的那个数。</p><p><strong>示例 1:</strong></p><pre><code>输入: [1,2,3,4,5], k=4, x=3输出: [1,2,3,4]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [1,2,3,4,5], k=4, x=-1输出: [1,2,3,4]</code></pre><p><strong>说明:</strong></p><ol><li>k 的值为正数，且总是小于给定排序数组的长度。</li><li>数组不为空，且长度不超过 104</li><li>数组里的每个元素与 x 的绝对值不超过 104</li></ol><p><strong>更新(2017/9/19):</strong><br>这个参数 <em>arr</em> 已经被改变为一个<strong>整数数组</strong>（而不是整数列表）。 <strong>请重新加载代码定义以获取最新更改。</strong></p><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本文参考这位大佬的题解[方法二： 二分查找最优区间的左边界]</p><p><a href="https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/</a></p><p>此问题转换为 <strong>查找最优区间的左边界</strong></p><pre><code>输入: [1,2,3,4,5], k=4, x=3输出: [1,2,3,4]</code></pre><p>例如这个示例，<strong>k为4</strong>，即区间的长度为4，这个区间可能是 <strong>[1,2,3,4] 和 [2,3,4,5]</strong>，所以最左边界元素的区间在 <strong>[0, 1]</strong>范围内</p><p>也就是说，<strong>最优区间的左边界</strong>在<strong>[0, length-k]</strong>这个区间中</p><p>那么，现在的问题就转换成了 在<strong>[0, length-k]</strong>区间内找到一个元素，这个元素是<strong>最优区间的左边界</strong></p><p>来整理一下题目的条件：</p><blockquote><p><strong>x</strong> ： 目标值</p><p><strong>k</strong> ： 结果数组内的元素个数</p></blockquote><ol><li>最优区间内的每个元素与 <strong>x</strong> 的差值都是最小的</li><li>找到的最优区间必须升序排列的</li></ol><h3 id="步骤解析"><a href="#步骤解析" class="headerlink" title="步骤解析"></a>步骤解析</h3><p>1.找到左边界元素所在区间</p><blockquote><p>这个很简单，就是[0, length-k]</p></blockquote><p>2.区间内的中位数(<strong>x - arr[mid]</strong>与<strong>arr[mid+k] - x</strong>进行比较)</p><blockquote><p>首先明白此时<strong>mid</strong>和<strong>mid+k</strong>各自代表的意义是什么？</p><p>mid：“最优区间”的左边界，可能当前不是最优区间，待进一步二分查找</p><p>mid+k：“最优区间”右边界的<strong>右边一位</strong></p><p>1) 如果<strong>x - arr[mid] &gt; arr[mid+k] - x</strong>,说明什么？</p><ul><li>说明 <strong>x</strong> 更应该靠近<strong>arr[mid+k]</strong>一些， 即<strong>arr[mid, mid+k]</strong>这个区间整体向右滑动，才可能成为 <strong>最优区间</strong></li><li>要使得这个区间<strong>向右滑动</strong>，也就是将这个区间的<strong>左边界右移</strong>。</li><li>回到二分查找，就是向右收缩 =&gt; <strong>left = mid + 1</strong></li></ul><p>2) 如果<strong>x - arr[mid] &lt; arr[mid+k] - x</strong>,说明什么？</p><ul><li>说明 <strong>mid + k位置 及 右边所有的元素</strong> 都不符合最优区间（因为是升序的），当前的“最优区间”为 arr[mid, mid + k]。但是mid之前可能存在有元素哦，所以mid之前的元素应该继续进行判断</li><li>mid之前的元素可能有更优的，就是区间<strong>可能向左移动</strong>，也可能当前mid就是最优区间的左边界（不移动）</li><li>为了找到更合适的mid，所以应该收缩[0, length-k]这个区间，因为是去找mid及mid之前的元素，所以是向左收缩，即 right = mid</li><li>为什么是right = mid，而不是right = mid - 1？因为mid这个位置的值，可能刚好就是<strong>最优区间的左边界</strong>，如果mid-1就错过了</li></ul><p>3) 如果<strong>x - arr[mid] = arr[mid+k] - x</strong>,说明什么？</p><ul><li>仔细想想，这两者差值相等的情况是和 <strong>2)</strong> 的情况一致</li></ul></blockquote><p>3.经过左右边界的不断收缩，最终找到的一个元素，这个元素就是 <strong>最优区间的左边界</strong>,即可求出答案</p><p><img src="https://s1.ax1x.com/2020/07/08/UVsOsg.gif" alt="程序执行动图"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="python">class Solution:    def findClosestElements(self, arr: List[int], k: int, x: int) -&gt; List[int]:        left, right = 0, len(arr) - k # 确定最优区间的左边界所在区间范围        while left &lt; right:            mid = (left + right) &gt;&gt; 1 # 找到中位数            if x - arr[mid] &gt; arr[mid+k] - x: # 比较差值，收缩区间                left = mid + 1            elif x - arr[mid] &lt;= arr[mid+k] - x:                right = mid        return arr[left:left+k]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23.合并K个排序列表</title>
      <link href="/2020/07/10/23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8/"/>
      <url>/2020/07/10/23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例:</strong></p><p>输入:</p><pre><code>[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]</code></pre><p>输出: <strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</strong></p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists</a></p><p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>此学习笔记，参考题解：</p><p>感谢！！</p><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/duo-tu-yan-shi-23-he-bing-kge-pai-xu-lian-biao-by-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/duo-tu-yan-shi-23-he-bing-kge-pai-xu-lian-biao-by-/</a></p><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/leetcode-23-he-bing-kge-pai-xu-lian-biao-by-powcai/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/leetcode-23-he-bing-kge-pai-xu-lian-biao-by-powcai/</a></p><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><blockquote><p>  依靠最小堆的特性，每次弹出必定是最小值</p></blockquote><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>步骤：</p><ol><li>将所有节点的加入到堆队列中</li><li>不断弹出，生成新的链表</li></ol><blockquote><p>  说明： 在python中，实例与实例之间不能直接使用 <code>&gt;</code>等比较运算符</p><p>  我们可以写一个魔术方法，使得〔ListNode〕之间可以大小比较</p><pre><code class="python">  def __lt__(self, other):      return self.val &lt; other.val  ListNode.__lt__ = __lt__</code></pre></blockquote><p>完整代码：</p><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        if not lists: return None        import heapq        queue = []        dummy = ListNode(-1)        def __lt__(self, other):            return self.val &lt; other.val        ListNode.__lt__ = __lt__        cur = dummy        # 将所有节点加入至堆队列中        for l in lists:            while l:                heapq.heappush(queue, l)                l = l.next        # 不断取出节点        while queue:            # 由于最小堆的特性，每次取出的节点都是最小的            node = heapq.heappop(queue)            cur.next = node            cur = cur.next        cur.next = None        return dummy.next</code></pre><p>空间复杂度： O(N)</p><h4 id="堆排序优化"><a href="#堆排序优化" class="headerlink" title="堆排序优化"></a>堆排序优化</h4><p>此方法是对上一方法的优化，在上面方法中是直接将所有的节点一股脑全部丢到堆队列中，这造成了空间的浪费。在此，可以将空间复杂度优化成<code>O(K)</code>，即链表的数量</p><p><img src="https://pic.leetcode-cn.com/a91253f60b46b4d804adff9d3af7fb54586018e173d480cf06f4530630f3eb8d-3.jpg" alt="演示图"></p><p>将每个链表的头结点，加入到堆队列即可，<strong>当此节点出队列时，立即判断此节点的指针域是否为空，不为空就表示后面还有节点，所以将后面的节点加入到堆队列中</strong>。如此一来，堆队列的空间大小就没有发生变换。</p><p>步骤：</p><ol><li>将所有链表的头节点加入到堆队列中</li><li>出队，将出来的节点连接到新节点上<code>dummy</code></li><li>检测刚出队的节点的指针域是否有效，有效则将下一个节点加入到堆队列中</li></ol><p>完整代码：</p><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        def __lt__(self, other):            return self.val &lt; other.val        ListNode.__lt__ = __lt__        if not lists:            return        import heapq        queue = []        dummy = ListNode(-1)        cur  = dummy        # 将所有的链表的头结点入队        for i in range(len(lists)):            head = lists[i]            if head:                heapq.heappush(queue, head)        # 从堆队列中弹出并检测是否还有下一个节点，有则加入到堆队列中        while queue:            node = heapq.heappop(queue)            cur.next = node            cur = cur.next            # 下一个节点是否有效            if node.next:                heapq.heappush(queue, node.next)        cur.next = None        return dummy.next</code></pre><h3 id="两两合并"><a href="#两两合并" class="headerlink" title="两两合并"></a>两两合并</h3><p>[简单]合并两个有序链表：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><p>之前做过一道题，实现两个有序链表的合并</p><p>本题是多个有序链表的合并，所以自然可以使用使用两两合并，合并到最后即成为一个有序链表</p><p>完整代码：</p><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        dummy = ListNode(float(&#39;-inf&#39;))        cur = dummy        for i in range(len(lists)):            cur = self.mergeTwoLists(cur, lists[i])        return dummy.next    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        dummy = ListNode(-1)        cur = dummy        while l1 and l2:            if l1.val &lt; l2.val:                cur.next = l1                l1 = l1.next            else:                cur.next = l2                l2 = l2.next            cur = cur.next        cur.next = l1 if l1 else l2        return dummy.next</code></pre><p>然而，效率极低</p><p><img src="https://s1.ax1x.com/2020/07/10/UK53rQ.png" alt="UK53rQ.png"></p><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>在排序算法中，一个〔归并排序〕</p><blockquote><p>  将无序的序列分解成一个一个，然后按有序方式组合</p></blockquote><p>归并排序中的 <strong>分治思想</strong> 可以在此题应用到</p><p><img src="https://pic.leetcode-cn.com/88d261465f1f21288dd23cef2f059297f5d053fc19805458a47ae1b05f3c0703-6.jpg" alt="6.jpg"></p><p>按照归并排序的案例或上图的演示，我们首先将 <strong>lists</strong> 中的链表一分再分， 然后按照大小关系一一合并</p><p>步骤：</p><ol><li>将 <strong>lists</strong> 一分再分，分到不能再分为止</li><li>不断合并</li><li>最后得到完整的有序链表</li></ol><blockquote><p>  步骤描述只是大概，具体还是得根据代码来慢慢理解，所以一定要写注释！！！</p></blockquote><p>完整代码：</p><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        if not lists: return         return self.merge(0, len(lists)-1, lists)    def merge(self, left, right, lists):        &quot;&quot;&quot;将lists不断分割，这里的操作有点像二分法        通过不断的一分二，分到最小单位        &quot;&quot;&quot;        if left == right:            return lists[left]        mid = (left + right) &gt;&gt; 1        l1 = self.merge(left, mid, lists)        l2 = self.merge(mid+1, right, lists)        # 调用合并函数，将 l1 和 l2合并成新有序链表        return self.mergeTwoLists(l1, l2)    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        &quot;&quot;&quot;将两个链表合成一个有序链表&quot;&quot;&quot;        dummy = ListNode(-1)        cur = dummy        while l1 and l2:            if l1.val &lt; l2.val:                cur.next = l1                l1 = l1.next            else:                cur.next = l2                l2 = l2.next            cur = cur.next        cur.next = l1 if l1 else l2        return dummy.next</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 分治算法 优先级队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找模板</title>
      <link href="/2020/07/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/07/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>最近又开始刷算法题，准备在这个暑假把算法练练。</p><p>本文模板均来自leetcode</p><p><a href="https://leetcode-cn.com/explore/learn/card/binary-search/" target="_blank" rel="noopener">https://leetcode-cn.com/explore/learn/card/binary-search/</a></p><h2 id="二分查找模板-1"><a href="#二分查找模板-1" class="headerlink" title="二分查找模板 #1"></a>二分查找模板 #1</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">def binarySearch(nums, target):    &quot;&quot;&quot;    :type nums: List[int]    :type target: int    :rtype: int    &quot;&quot;&quot;    if len(nums) == 0:        return -1    left, right = 0, len(nums) - 1    while left &lt;= right:        mid = (left + right) // 2        if nums[mid] == target:            return mid        elif nums[mid] &lt; target:            left = mid + 1        else:            right = mid - 1    # End Condition: left &gt; right    return -1</code></pre><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><blockquote><p>用于查找可以通过<em>访问数组中的单个索引</em>来确定的元素或条件。</p></blockquote><h2 id="二分查找模板-2"><a href="#二分查找模板-2" class="headerlink" title="二分查找模板 #2"></a>二分查找模板 #2</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">def binarySearch(nums, target):    &quot;&quot;&quot;    :type nums: List[int]    :type target: int    :rtype: int    &quot;&quot;&quot;    if len(nums) == 0:        return -1    left, right = 0, len(nums) # 注意right = len(nums)    while left &lt; right:        mid = (left + right) // 2        if nums[mid] == target:            return mid        elif nums[mid] &lt; target:            left = mid + 1        else:            right = mid    # Post-processing:    # End Condition: left == right    if left != len(nums) and nums[left] == target:        return left    return -1</code></pre><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><blockquote><p>模板 #2 是二分查找的高级模板。它用于查找需要<em>访问数组中*</em>当前索引及其直接右邻居索引***的元素或条件。</p></blockquote><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h4><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给定一个输入数组 <code>nums</code>，其中 <code>nums[i] ≠ nums[i+1]</code>，找到峰值元素并返回其索引。</p><p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code>。</p><p><strong>示例 1:</strong></p><pre><code>输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2；     或者返回索引 5， 其峰值元素为 6。</code></pre><p><strong>说明:</strong></p><p>你的解法应该是 <em>O</em>(<em>logN</em>) 时间复杂度的。</p><h2 id="二分查找模板-3"><a href="#二分查找模板-3" class="headerlink" title="二分查找模板 #3"></a>二分查找模板 #3</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">def binarySearch(nums, target):    &quot;&quot;&quot;    :type nums: List[int]    :type target: int    :rtype: int    &quot;&quot;&quot;    if len(nums) == 0:        return -1    left, right = 0, len(nums) - 1    while left + 1 &lt; right:        mid = (left + right) // 2        if nums[mid] == target:            return mid        elif nums[mid] &lt; target:            left = mid        else:            right = mid    # Post-processing:    # End Condition: left + 1 == right    if nums[left] == target: return left    if nums[right] == target: return right    return -1</code></pre><h3 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h3><blockquote><p>模板 #3 是二分查找的另一种独特形式。 它用于搜索需要<em>访问当前索引及其在数组中的直接左右邻居索引</em>的元素或条件。</p></blockquote><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3>]]></content>
      
      
      <categories>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
