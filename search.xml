<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>插入排序</title>
      <link href="/2020/07/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/07/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每次将一个数字插入到一个有序数组中，成为一个更长的有序数组，在有限次操作之后，数组整体有序</p><a id="more"></a><h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="http://cdn.z2blog.com/img/20200719104503.gif" alt=""></p><p>根据上方演示，可以直观的看出，从后面依次取数字，然后插入到前方有序的数组中</p><p>图片来源： <a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">https://visualgo.net/zh/sorting</a></p><h2 id="边想边写"><a href="#边想边写" class="headerlink" title="边想边写"></a>边想边写</h2><ul><li>既然需要从后续数组中依次取值，所以必然会遍历这个数组</li></ul><pre><code class="python">def insert_sort(nums):    length = len(nums)    for i in range(1, length):        # ...</code></pre><ul><li>当取出一个数字时，我们需要与前面的有序数组依次比较，找到「合适的插入位置」，根据演示图，是逆序遍历「有序数组」的</li></ul><pre><code class="python">def insert_sort(nums):    length = len(nums)    for i in range(1, length):        for j in range(i-1, -1, -1):            # ...</code></pre><p>这里解释下 <code>range(i-1, -1, -1)</code>的写法，这是<code>python</code>的逆序遍历</p><blockquote><p>  第一个参数<code>i-1</code>， 这个很好理解，我在第<code>i</code>个位置，取出这个数字，自然需要逆序遍历，<code>i</code>之前的有序数组，所以是从<code>i-1</code></p><p>  第二个参数<code>-1</code> ，这个是遍历的步长，这里表示每次遍历的跨度为<code>1</code>，因为是逆序，遍历的索引需要不断减小，所以是<code>-1</code></p><p>  第三个参数<code>-1</code>，表示「逆序遍历」</p></blockquote><ul><li>在逆序遍历有序数组的过程中，不断比较，找到合适位置并“插入”</li></ul><pre><code class="python">def insert_sort(nums):    length = len(nums)    for i in range(1, length):        for j in range(i-1, -1, -1):            if nums[i] &gt;= nums[j]:                break            elif nums[i] &lt; nums[j]:                nums[i], nums[j] = nums[j], nums[i]</code></pre><blockquote><p>  在大于等于的情况下，此时我们所取出来的<code>nums[i]</code> 是前面「有序数组」中的最大值，所以可以<strong>提前终止此内循环</strong>，避免后续无用的操作</p><p>  在小于的情况下，则需要将<code>nums[i]</code>与有序数组部分逆序比较，这里的 “插入” 并非是真的插入，而完成 “插入”操作，我们可以使用「值交换」</p><p>  完成一次「值交换」后，还需要向前比较，所以应该更改它们的索引值，<code>i</code>是我们取出来的数字的索引，当交换发生后，此时 <code>i</code> 所表示的值发生了改变，此时我们应该将 <code>i</code> 重新表示为 「取出来的数字」，看文字有点绕，看下图</p></blockquote><p><img src="http://cdn.z2blog.com/img/20200719111301.gif" alt=""></p><p><code>j</code>移动是交给循环的，所以我们只需要让<code>i</code>向前移动即可</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="python">def insert_sort(nums):    length = len(nums)    for i in range(1, length):        for j in range(i-1, -1, -1):            if nums[i] &gt;= nums[j]:                break            elif nums[i] &lt; nums[j]:                nums[i], nums[j] = nums[j], nums[i]                i = j # 或者 i -= 1    return nums</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试用例： <a href="https://leetcode-cn.com/submissions/detail/89203696/testcase/" target="_blank" rel="noopener">https://leetcode-cn.com/submissions/detail/89203696/testcase/</a></p><p>使用此算法，<strong>用时：156.1655251979828</strong></p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h2><ul><li>时间复杂度：<em>O(n^2^)</em>，这里 <img src="https://cdn.nlark.com/yuque/__latex/8d9c307cb7f3c4a32822a51922d1ceaa.svg" alt="img"> 是数组的长度；</li><li>空间复杂度：<em>O(1)</em>，使用到常数个临时变量。</li></ul><h2 id="插入排序的特点（重要）"><a href="#插入排序的特点（重要）" class="headerlink" title="插入排序的特点（重要）"></a>插入排序的特点（重要）</h2><ul><li>「插入排序」可以提前终止内层循环；</li><li>在数组「几乎有序」的前提下，「插入排序」的时间复杂度可以达到 <img src="https://cdn.nlark.com/yuque/__latex/33697ce7dfa48ba80980d298c8089378.svg" alt="img">，因此「插入排序」可以作为高级排序算法的一个子过程（后面再「归并排序」和「快速排序」算法里我们会看到）。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.yuque.com/liweiwei1419/algo/pbpdec#Bdb7S" target="_blank" rel="noopener">https://www.yuque.com/liweiwei1419/algo/pbpdec#Bdb7S</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2020/07/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/07/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h2><p>每一轮选取未排定的部分中<strong>最小</strong>的那个元素交换到未排定部分的最开头，经过若干个步骤，就能排定整个数组。即：先选出最小的，再选出第二小的，以此类推。</p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><pre><code class="python">def select_sort(list):    for j in range(len(list)):        min_pos = j        for i in range(j, len(list)):            if list[min_pos] &gt; list[i]:                min_pos = i        list[j], list[min_pos] = list[min_pos], list[j]    return list</code></pre><h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a><strong>动图演示</strong></h2><p>结合代码更容易理解</p><blockquote><p>  红色： 标记最小值，同代码中的<code>minIndex</code></p><p>  绿色： 内循环，用于遍历找到「未排序部分」中的最小值，同代码中的<code>j</code></p></blockquote><p><img src="http://cdn.z2blog.com/img/20200719102518.gif" alt=""></p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h2><ul><li>时间复杂度：<img src="https://cdn.nlark.com/yuque/__latex/8e9c5fee65a4f32abccd0e83ff203e39.svg" alt="img">，这里 <img src="https://cdn.nlark.com/yuque/__latex/8d9c307cb7f3c4a32822a51922d1ceaa.svg" alt="img"> 是数组的长度；</li><li>空间复杂度：<img src="https://cdn.nlark.com/yuque/__latex/5e079a28737d5dd019a3b8f6133ee55e.svg" alt="img">，使用到常数个临时变量。</li></ul><h2 id="练习测试"><a href="#练习测试" class="headerlink" title="练习测试"></a>练习测试</h2><p><a href="https://leetcode-cn.com/problems/sort-an-array/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-an-array/submissions/</a></p><p>我用的python，在此题中使用选择排序，会超出时间限制。</p><p>超出时间限制的用例： <a href="https://leetcode-cn.com/submissions/detail/89203696/testcase/" target="_blank" rel="noopener">https://leetcode-cn.com/submissions/detail/89203696/testcase/</a></p><p>我在本次测试了这个用例，<strong>用时：87.07884120941162</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="算法思想-1：贪心算法"><a href="#算法思想-1：贪心算法" class="headerlink" title="算法思想 1：贪心算法"></a>算法思想 1：贪心算法</h3><p>每一次决策只看当前，当前最优，则全局最优。注意：这种思想不是任何时候都适用。</p><h3 id="算法思想-2：减治思想"><a href="#算法思想-2：减治思想" class="headerlink" title="算法思想 2：减治思想"></a>算法思想 2：减治思想</h3><p>外层循环每一次都能排定一个元素，问题的规模逐渐减少，直到全部解决，即「大而化小，小而化了」。运用「减治思想」很典型的算法就是大名鼎鼎的「二分查找」。</p><h3 id="选择排序的优点：交换次数最少"><a href="#选择排序的优点：交换次数最少" class="headerlink" title="选择排序的优点：交换次数最少"></a>选择排序的优点：交换次数最少</h3><p>「选择排序」看起来好像最没有用，但是如果在交换成本较高的排序任务中，就可以使用「选择排序」（《算法 4》相关章节课后练习题）。</p><p>依然是建议大家不要对算法带有个人色彩，在面试回答问题的时候和看待一个人和事物的时候，可以参考的回答模式是「具体问题具体分析，在什么什么情况下，用什么什么算法」。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.yuque.com/liweiwei1419/algo/sfqelg#s6dqC" target="_blank" rel="noopener">https://www.yuque.com/liweiwei1419/algo/sfqelg#s6dqC</a></p><p><a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">https://visualgo.net/zh/sorting</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>287.寻找重复数</title>
      <link href="/2020/07/13/287.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
      <url>/2020/07/13/287.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定一个包含 <code>n + 1</code> 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>示例 1:</p><pre><code>输入: [1,3,4,2,2]输出: 2</code></pre><p>示例 2:</p><pre><code>输入: [3,1,3,4,2]输出: 3</code></pre><p>说明：</p><ul><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-the-duplicate-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-duplicate-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><a id="more"></a><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h2><p>看了标签有 「二分查找」，我就一直琢磨这个用「二分查找」怎么完成这道题</p><ul><li><p><strong>排序</strong></p><p>二分查找需要有序数组，所以在查找前必须排序。</p><p>题目要求「不能更改原数组（假设数组是只读的）」，但是我们可以将排序好的结果放入新的数组中，满足要求「只能使用额外的 O(1) 的空间」</p></li><li><p><strong>求中位数</strong></p><p>既然求<code>mid</code>，那么我们需要知道大小范围才能求吧。</p><p>仔细审题 「<code>n + 1</code> 个整数的数组 nums」， 「数字都在 1 到 n 之间」</p><pre><code class="python">length = len(nums) # 求出数组长度 n+1n = length - 1     # 数字都在1到n之间</code></pre><p>所以，范围是 <code>[0, len(nums)-1]</code></p><pre><code class="python">length = len(nums) # 求出数组长度 n+1n = length - 1     # 数字都在1到n之间left = 0right = n...mid = (left + right) &gt;&gt; 1</code></pre></li></ul><ul><li><p><strong>与谁比较，怎么比较？</strong></p><p>「二分查找」的特性就是，按中位数将有序数组一分为二，每次选择满足条件的一半，继续二分</p><p>那么，现在的问题就是 「如何知道重复元素在哪一半？」</p><p>重要信息：</p><p><strong>只有一个重复元素</strong> <strong>数字范围是[0, len(nums)-1]</strong></p><p>举例来说明，当前有一个有序数组 [1,2,3,4,4]，这个数组长度为5，而数字取值范围是[1, 4]，就算一字排开[1,2,3,4] 也只有4个元素，所以剩下一个元素，必定重复。绕了个弯子，那么如何找重复元素呢？</p><p><strong>可以把每个不同的数字，看做是不同种类的萝卜，一个坑位对应一种类型的萝卜</strong></p><p>在此例中，第一次<code>mid</code>是<code>2</code>，对应的元素值是<code>3</code>，用<code>rihgt-mid</code>我们得知mid之后还有两个位置</p><p>然而用<code>nums[right]-nums[mid]</code>，差值为<code>1</code>，小于剩余位置的个数，这就可以说明重复元素在mid的右边部分。这就好像，<strong>坑有两个，但是只有一个品种的萝卜</strong></p><p>换个例子[1,2,2,3,4],在这个例子中的第一次计算mid之后，<code>nums[right]-nums[mid]</code> 等于 <code>right-mid</code>，mid右边部分就符合 <strong>一个坑位对应一个品种</strong></p><p>形象一点：</p><p><code>rihgt-mid</code>： 计算坑位</p><p><code>nums[right]-nums[mid]</code>：计算萝卜品种数</p><p>经过上面的分析，得出结果：</p><blockquote><p>  如果right - mid &gt; nums[right] - nums[mid]</p><p>  表示重复元素在右边，即向右收缩，<code>left = mid</code>，因为<code>mid</code>可能刚好是重复元素，所以不是 left = mid + 1</p><p>  否则表示重复元素在左边，即向左收缩，<code>right = mid</code></p></blockquote></li><li><p><strong>循环何时退出？</strong></p><p>通过上面的分析，左右收缩的时候都是 <code>=mid</code>，观望大佬们总结的模板，此等情况循环的结束条件为 <code>left + 1 = right</code></p></li></ul><h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="http://cdn.z2blog.com/img/20200713230426.gif" alt=""></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="python">class Solution:    def findDuplicate(self, nums: List[int]) -&gt; int:        length = len(nums)        n = length - 1        left, right = 0, n        nums = sorted(nums)        while left + 1 &lt; right:            mid = (left + right) &gt;&gt; 1            if nums[right] - nums[mid] &lt; right - mid:                left = mid            else:                right = mid        return nums[left]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>349&amp;350.两个数组的交集</title>
      <link href="/2020/07/13/349&amp;350.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
      <url>/2020/07/13/349&amp;350.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h1><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>示例 1：</p><pre><code>输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2]</code></pre><p>示例 2：</p><pre><code>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]</code></pre><p>说明：</p><p>输出结果中的每个元素一定是唯一的。<br>我们可以不考虑输出结果的顺序。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-arrays</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><a id="more"></a><h2 id="排序-双指针"><a href="#排序-双指针" class="headerlink" title="排序+双指针"></a>排序+双指针</h2><h3 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h3><ol><li>对两个数组进行升序排序</li><li>为两个数组分别设置两个「指针」 p1 p2，初始值为0</li><li>比较<code>nums1[p1]</code>与<code>nums2[p2]</code></li></ol><blockquote><p>  1) nums1[p1] &gt; nums2[p2]</p><p>  两个数组都是升序排序，假如<code>nums1[p1]</code>这个元素在<code>nums2</code>中存在「同等大小的元素」，那么必定在当前<code>p2</code>的后面，所以此时执行 <code>p2 += 1</code>，<code>p2</code>指针向右移动一位</p><p>  2) nums1[p1] &lt; nums2[p2]</p><p>  与上方同理 <code>p1 += 1</code></p><p>  3) nums1[p1] == nums2[p2]</p><p>  这时即找到了「交集」，将此元素加入新的数组中，方便我们之后输出</p><p>  在题目中有要求「输出结果中的每个元素一定是唯一的。」</p><p>  所以，当满足相等情况时，应该判断「结果数组」中，是否已经有同等大小的元素存在了</p><p>  有则跳过，无则添加</p><p>  然后，p1 p2 同时向右移动一位</p></blockquote><ol start="4"><li>重复「步骤3」</li></ol><blockquote><p>  重复步骤3，什么时候结束循环呢？</p><p>  两个指针都在向右走，当其中一个「指针」等于其数组长度时，即退出循环。</p><p>  可以在每次循环开始前，判断两个指针是否越界，越界就退出循环</p></blockquote><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="http://cdn.z2blog.com/img/20200713145202.gif" alt=""></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="python">class Solution:    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        p1, p2 = 0, 0        nums1.sort()        nums2.sort()        res = []        while 1:            # 判断是否越界            if p1 == len(nums1) or p2 == len(nums2): break            if nums1[p1] &gt; nums2[p2]:                p2 += 1            elif nums1[p1] &lt; nums2[p2]:                p1 += 1            else:                # 判断元素是否存在，避免重复元素                if nums2[p2] not in res:                    res.append(nums2[p2])                # 两个指针同时向右移动                p1 += 1                p2 += 1        return res</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(m \log m+n \log n)O(mlogm+nlogn)，其中 mm 和 nn 分别是两个数组的长度。对两个数组进行排序的时间复杂度是 O(m \log m+n \log n)O(mlogm+nlogn)，遍历两个数组的时间复杂度是 O(m+n)O(m+n)，因此总时间复杂度是 O(m \log m+n \log n)O(mlogm+nlogn)。</p><p>空间复杂度：O(\min(m,n))O(min(m,n))，其中 mm 和 nn 分别是两个数组的长度。为返回值创建一个数组 intersection，其长度为较短的数组的长度。不过在 C++ 中，我们可以直接创建一个 vector，不需要把答案临时存放在一个额外的数组中，所以这种实现的空间复杂度为 O(1)。</p><h1 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a>两个数组的交集 II</h1><p>给定两个数组，编写一个函数来计算它们的交集。 </p><p>示例 1：</p><pre><code>输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2]</code></pre><p>示例 2:</p><pre><code>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9]</code></pre><p>说明：</p><p>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。<br>我们可以不考虑输出结果的顺序。<br>进阶：</p><p>如果给定的数组已经排好序呢？你将如何优化你的算法？<br>如果 nums1 的大小比 nums2 小很多，哪种方法更优？<br>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><h2 id="排序-双指针-1"><a href="#排序-双指针-1" class="headerlink" title="排序+双指针"></a>排序+双指针</h2><p>在此题中多了一个要求「输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致」</p><p>同样可以使用「排序+双指针」的方法解决此题。</p><p>唯一有所不同的是，当遇到<code>nums1[p1] == nums2[p2]</code>时，不用再去判断「结果数组」中是否已经存在同等大小的元素。</p><h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="python">class Solution:    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        p1, p2 = 0, 0        nums1.sort()        nums2.sort()        res = []        while 1:            # 判断是否越界            if p1 == len(nums1) or p2 == len(nums2): break            if nums1[p1] &gt; nums2[p2]:                p2 += 1            elif nums1[p1] &lt; nums2[p2]:                p1 += 1            else:                res.append(nums2[p2])                # 两个指针同时向右移动                p1 += 1                p2 += 1        return res</code></pre><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="思路及算法-1"><a href="#思路及算法-1" class="headerlink" title="思路及算法"></a>思路及算法</h3><p>摘自官方题解</p><blockquote><p>  由于同一个数字在两个数组中都可能出现多次，因此需要用哈希表存储每个数字出现的次数。对于一个数字，其在交集中出现的次数等于该数字在两个数组中出现次数的最小值。</p><p>  首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。</p><p>  为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集。</p><p>  作者：LeetCode-Solution<br>  链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/</a><br>  来源：力扣（LeetCode）<br>  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p>官方做的图解好好看，自己做的有点点小丑，哈哈哈</p><p><img src="http://cdn.z2blog.com/img/20200713152800.gif" alt="来源leetcode"></p><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="python">class Solution:    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        import collections        # 构建nums1的元素个数表        c = collections.Counter(nums1)        res = []        for n in nums2:            if n in c:                if c[n] != 0:                    # 如果等于0了，则表示nums2中的这个元素数量比nums1多                    # 而题目要求按最小值                    c[n] -= 1                    res.append(n)        return res</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>153&amp;154.寻找旋转排序数组中的最小值</title>
      <link href="/2020/07/12/153&amp;154.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
      <url>/2020/07/12/153&amp;154.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153.寻找旋转排序数组中的最小值"></a>153.<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a></h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><pre><code>示例 1:输入: [3,4,5,1,2]输出: 1示例 2:输入: [4,5,6,7,0,1,2]输出: 0</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><a id="more"></a><h2 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h2><h3 id="方法一：与right比较"><a href="#方法一：与right比较" class="headerlink" title="方法一：与right比较"></a>方法一：与right比较</h3><p>一个有序数组，通过旋转后，可视化如下：</p><p><img src="http://cdn.z2blog.com/img/20200712183006.png" alt=""></p><p>通过上图，可以知道以下信息：</p><ul><li>左边有序数组元素均大于右边有序数组元素</li><li>最大值的右边就是最小值</li></ul><p>二分查找的标准起手</p><pre><code class="python">left = 0right = len(nums) - 1</code></pre><p>可求得<code>mid</code>值</p><h4 id="比较分析"><a href="#比较分析" class="headerlink" title="比较分析"></a>比较分析</h4><ol><li>nums[mid] &gt; nums[right]</li></ol><blockquote><p>  只有「左边有序数组的元素」才会大于「右边有序数组的最大元素」</p><p>  所以这说明，<code>mid</code>太靠左了，应该向右收缩</p><p>  <code>left = mid +1</code></p></blockquote><ol start="2"><li>nums[mid] &lt; nums[right]</li></ol><blockquote><p>  这也很明显，只有在「右边有序数组的元素」才可能小于 nums[right]</p><p>  所以说明，<code>mid</code>值太靠右了，应该向左收缩</p><p>  <code>right = mid</code></p><p>  注意：</p><p>  为什么<code>right</code> 不是 <code>mid + 1</code>，仔细想想当前<code>mid</code>在「右边有序数组」，所以有可能<code>mid</code>就是正确答案，如果改成<code>mid+1</code>则可能找不到</p></blockquote><p>循环退出的条件：</p><blockquote><p>  这里所做的 left = mid + 1， right = mid</p><p>  典型的「左闭右开区间」，看大佬们总结的模板，这种情况就是循环不变式  <code>while left &lt; right</code></p><p>  即 当 <code>left = right</code> 时退出循环</p></blockquote><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="http://cdn.z2blog.com/img/20200712184817.gif" alt=""></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><pre><code class="python">class Solution:    def findMin(self, nums: List[int]) -&gt; int:        left, right = 0, len(nums) - 1        while left &lt; right:            mid = (left + right) &gt;&gt; 1            if nums[mid] &gt; nums[right]:                left = mid + 1            elif nums[mid] &lt; nums[right]:                right = mid        return nums[left]</code></pre><h3 id="方法二：与nums-0-比较"><a href="#方法二：与nums-0-比较" class="headerlink" title="方法二：与nums[0]比较"></a>方法二：与nums[0]比较</h3><p><img src="http://cdn.z2blog.com/img/20200712183006.png" alt=""></p><p>通过观察，可以知道，<strong>最大值的右侧即最小值</strong></p><h4 id="比较分析-1"><a href="#比较分析-1" class="headerlink" title="比较分析"></a>比较分析</h4><p>让<code>mid</code>值一直与<code>nums[0]</code>比较</p><ol><li>nums[mid] &gt; nums[0]</li></ol><blockquote><p>  表示当前mid所处位置为「左边的有序数组」中</p><p>  向右收缩</p><p>  <code>left = mid + 1</code></p></blockquote><ol start="2"><li>nums[mid] &lt; nums[0]</li></ol><blockquote><p>  毫无疑问，此时<code>mid</code>在「右边的有序数组」中</p><p>  向左收缩</p><p>  <code>right = mid - 1</code></p></blockquote><p>这里可能有疑问了，如果<code>mid</code>刚好就是答案，那么<code>right = mid - 1</code>不就直接错过了吗？</p><blockquote><p>  <code>left</code>与<code>right</code>的最小增量都是<code>1</code></p><p>  对于right，只会出现两种情况</p><p>  情况一，执行<code>right = mid - 1</code>之后，依然在「右边的有序数组」中</p><p>  情况二，mid当前刚好就在「最小值」的位置，则right将会在「最大值」位置，而此后的所有<code>mid</code>值都只会在「左边的有序数组」中，即right的值将不会变换。随着<code>left</code>值的增加，将会在某一时刻满足<code>nums[mid] &gt; nums[mid+1]</code>，即此时 <code>num[mid+1]</code>就是最小值</p></blockquote><h4 id="满足条件"><a href="#满足条件" class="headerlink" title="满足条件"></a>满足条件</h4><p>随着left的右移，如果满足以下条件即找到「最小值」</p><ol><li>nums[mid-1] &gt; nums[mid]</li></ol><blockquote><p>  最小值为nums[mid]</p></blockquote><ol start="2"><li>nums[mid+1] &lt; nums[mid]</li></ol><blockquote><p>  最小值为nums[mid+1]</p></blockquote><h4 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="http://cdn.z2blog.com/img/20200712194103.gif" alt=""></p><h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><pre><code class="python">class Solution:    def findMin(self, nums: List[int]) -&gt; int:        n = len(nums)        if n == 1:            return nums[0]        left, right = 0, n - 1        # 如果最后一位大于第一位，则表示此数组单调自增，即最小值为第一位元素        if nums[n-1] &gt; nums[0]:            return nums[0]        while left &lt;= right:            mid = (left + right) &gt;&gt; 1            if nums[mid] &gt; nums[mid+1]:                return nums[mid+1]            if nums[mid] &lt; nums[mid-1]:                return nums[mid]            if nums[mid] &gt; nums[0]:                left = mid + 1            elif nums[mid] &lt; nums[0]:                right = mid - 1</code></pre><h1 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154.寻找旋转排序数组中的最小值 II"></a>154.<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii" target="_blank" rel="noopener">寻找旋转排序数组中的最小值 II</a></h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><pre><code>示例 1：输入: [1,3,5]输出: 1示例 2：输入: [2,2,2,0,1]输出: 0</code></pre><p>说明：</p><p>这道题是 「寻找旋转排序数组中的最小值」 的延伸题目。<br>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><h2 id="思路及算法-1"><a href="#思路及算法-1" class="headerlink" title="思路及算法"></a>思路及算法</h2><p>此题相比 <code>153</code> 多了一条设定「数组中可能存在重复的元素」</p><h3 id="方法一：与right比较-1"><a href="#方法一：与right比较-1" class="headerlink" title="方法一：与right比较"></a>方法一：与right比较</h3><p>此时按照上一题的解法，会出现什么问题呢？</p><p>举个例子 旋转数组 <code>[3,3,3,1,2,3]</code></p><p>取出<code>mid</code>为3，在上一题中，可以通过<code>mid</code>来区分目标值在哪一侧，而这里则不行了</p><p><code>mid</code>无法明确地将数组一分为二，究其原因是<code>mid</code>和<code>right</code>大小相同造成的，只要解决这一问题，再结合上一题的解法，这道题就可以解决了。</p><p>当<code>nums[mid] = nums[right]</code>时，可以保险的将 <code>right</code> -1</p><blockquote><p>  right位置的元素，是「右边有序数组中的最大值」，将最大值「减1」，即向左以最小单位「1」进行收缩了一次</p><p>  在上题的操作中，向左收缩是通过<code>right = mid</code>，进行大范围的快速收缩，这里采用「减1」的方法收缩是最为保险的。</p></blockquote><h4 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="http://cdn.z2blog.com/img/20200712220716.gif" alt=""></p><h4 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h4><pre><code class="python">class Solution:    def findMin(self, nums: List[int]) -&gt; int:        left, right = 0, len(nums) - 1        while left &lt; right:            mid = (left + right) &gt;&gt; 1            if nums[mid] &gt; nums[right]:                left = mid + 1            elif nums[mid] &lt; nums[right]:                right = mid            elif nums[mid] == nums[right]:                right -= 1        return nums[left]</code></pre><p>参考题解：</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>378.有序矩阵中第K小的元素</title>
      <link href="/2020/07/12/378.%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
      <url>/2020/07/12/378.%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。 </p><p>示例：</p><pre><code>matrix = [   [ 1,  5,  9],   [10, 11, 13],   [12, 13, 15]],k = 8,返回 13。</code></pre><p>提示：<br>你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><a id="more"></a><p>此笔记参考题解：</p><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/you-xu-ju-zhen-zhong-di-kxiao-de-yuan-su-by-leetco/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/you-xu-ju-zhen-zhong-di-kxiao-de-yuan-su-by-leetco/</a></p><h1 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h1><p>从左到右递增，从上往下递增，即<code>matrix[0][0]</code>是最小值，<code>matrix[n-1][n-1]</code>是最大值。我们所需找到的第Ｋ小元素必定在<code>[matrix[0][0], matrix[n-1][n-1]]</code>区间内。</p><p>至此，<strong>有序</strong>　＋　<strong>确定范围</strong>　可以使用<strong>二分查找</strong></p><p>让　<code>left = matrix[0][0]</code> <code>right = matrix[n-1][n-1]</code></p><p>则有 <code>mid = (left + right) &gt;&gt; 1</code></p><p>以下方这个矩阵举例</p><p><img src="/home/mk/Desktop/U1VQJJ.png" alt="U1VQJJ.png"></p><h2 id="分割矩阵"><a href="#分割矩阵" class="headerlink" title="分割矩阵"></a>分割矩阵</h2><p>第一次计算<code>mid = (1 + 16) &gt;&gt; 1 = 8</code></p><p>以<code>mid</code>为界，可以将整个矩阵分割成两个部分，那怎么分？</p><p>重要条件 <strong>每行和每列元素均按升序排序</strong></p><p>从左下角开始的元素开始，不断往右走，当元素小于或等于<code>mid</code>，则此元素及上方所有元素，均是比<code>mid</code>值小的元素。 文字表达不太清楚，看图比较直观。橙色部分都是<code>&lt;=mid</code>的元素</p><p><img src="https://s1.ax1x.com/2020/07/11/U1nOD1.png" alt="U1nOD1.png"></p><p>通过<code>mid</code>将矩阵一分为二，则需要我们判断<strong>第k小元素在哪一边</strong></p><blockquote><p>  这里和常规的二分查找类似，都需要依据mid来判定目标元素在左右的哪一边</p></blockquote><p>但这里又和二分查找又有点区别，就是我们<strong>拿什么与什么进行比较</strong></p><h2 id="确定查找范围"><a href="#确定查找范围" class="headerlink" title="确定查找范围"></a>确定查找范围</h2><p>第一，明白 <strong>寻找第k小元素</strong> 的区间内元素个数要求</p><p>举个例子：<code>1,2,3,4</code>，第3小的元素，那么是3；<code>1,2,2,3,4</code>，同样是第3小的，则是2</p><p>由此可知，要找到第k小元素，那么这个区间中至少至少得有k个元素吧！</p><p>第二， <code>mid</code>将矩阵分割成两部分，我们简单可以看成<strong>较小元素的部分</strong>和<strong>较大元素的部分</strong>，既然寻找第k<strong>小元素</strong>，结合第一个解释，所以，较小元素部分的元素个数应该是<strong>大于等于k的</strong></p><p>至此，我们知道是 <strong>num</strong>(元素较小部分的元素个数) 与 <strong>k</strong>之间的比较</p><h2 id="比较num与k"><a href="#比较num与k" class="headerlink" title="比较num与k"></a>比较num与k</h2><p>怎么个比较法？</p><p>如果 <strong>num &gt;= k</strong> ，说明 <strong>较小元素部分的范围太大了</strong> 需要缩小范围，即「边界收缩」</p><blockquote><p>   right = mid</p></blockquote><p>如果 <strong>num &lt; k</strong>，说明 <strong>较小元素部分的范围太小了</strong> 需要扩大范围</p><p>这里说明下，待查找范围的大小与<code>right</code>有关，而<code>left</code>的作用是查找元素。</p><p>即 <code>right</code>将一个大致的范围给定好，然后<code>left</code>在范围内「猜」元素</p><p><strong>直接限定</strong>范围大小的元素是<code>right</code>吗？不是，是<code>mid</code>。因为我们是以<code>mid</code>为中线，进行分割，所以想<strong>扩大范围</strong>，就是<strong>增大<code>mid</code>值</strong>，增大mid意味着增大<code>left</code>或<code>right</code></p><blockquote><p>  left = mid + 1</p></blockquote><p>经过 <code>while left &lt; right</code> 循环，最终跳出循环 <code>return left</code>，left即是答案</p><p><img src="http://cdn.z2blog.com/img/20200711232803.gif" alt="动图演示"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="python">class Solution:    def kthSmallest(self, matrix: List[List[int]], k: int) -&gt; int:        n = len(matrix)        def check(mid):            &quot;&quot;&quot;遍历获取较小元素部分元素总数，并与k值比较&quot;&quot;&quot;            i, j = n-1, 0            num = 0            while i &gt;= 0 and j &lt; n:                if matrix[i][j] &lt;= mid:                    # 当前元素小于mid，则此函数及上方函数均小于mid                    num += i + 1                    # 向右移动                    j += 1                else:                    # 当前元素大于mid，则向上移动，直到找到比mid小的值，或者出矩阵                    i -= 1            return num &gt;= k        left, right = matrix[0][0], matrix[-1][-1]        while left &lt; right:            mid = (left + right) &gt;&gt; 1            if check(mid):                # 满足 num &gt;= k，范围太大，移动right至mid， 范围收缩                right = mid            else:                left = mid + 1        return left</code></pre><h2 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h2><h3 id="为什么left就一定是在矩阵中呢？"><a href="#为什么left就一定是在矩阵中呢？" class="headerlink" title="为什么left就一定是在矩阵中呢？"></a>为什么left就一定是在矩阵中呢？</h3><blockquote><p>  <code>matrix[0][0]</code> 与 <code>matrix[n-1][n-1]</code>是存在矩阵中，而计算出来的<code>mid</code>，可能不在矩阵中，也就意味后续相关的<code>left</code>与<code>right</code>也可能不在矩阵中，那么为什么偏偏<code>left</code>就在矩阵中而且还是正确答案呢？</p></blockquote><p>先来看一个简单的矩阵示例：</p><p><img src="http://cdn.z2blog.com/img/20200711235324.png" alt=""></p><p><strong>要求：找到第2小的元素</strong></p><p>在这个矩阵中，第一次<code>mid</code>计算值为<code>50</code>（不在矩阵中），以<code>50</code>为分割，得到的<code>num</code>为<code>1</code></p><p>在循环中，<code>num</code> 一直小于<code>k</code>， 则<code>left</code> 一直在做 <code>mid + 1</code>，最终加到<code>80</code>的时候，mid = (80 + 100) / 2 = 90，至此使得<code>num</code>为<code>2</code>，此时<code>num=k</code>，即<code>right = mid = 90</code>，<code>left</code>继续做<code>mid+1</code>，当加到<code>90</code>时，left = right，退出循环，返回<code>left</code>，即90</p><p>通过这个简单的矩阵，就知道 第k小的值不是直接算出来的，而是「猜」出来的，二分查找就是在不断缩小范围并猜值</p><p>回到问题，为什么left就一定是在矩阵中呢？</p><p>上面的示例，退出循环时，必定有<code>left=right</code>，返回<code>left</code>即返回<code>right</code>，所以<code>right</code>的值是最终答案</p><p>好的，那么<code>right</code>的值怎么来滴，由<code>right=mid</code>可知，<code>mid</code>决定<code>right</code></p><p>所以，<code>mid</code>就是最终答案(有特例，比如<code>[[-5]]</code>)， 这里只是笼统的认为，方便理解</p><p>(left + right) / 2 决定了<code>mid</code>， left的变换是因为<code>num&lt;k</code></p><p><strong>因为<code>left</code>在不停的失错，直到使得mid的值，可以满足num&gt;=k</strong></p><p>这也说明了，此方法只适用于<strong>整数矩阵</strong>，如果是小数就不行了，因为每次试错的最小增量是<strong>1</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>658.找到K个最接近的元素</title>
      <link href="/2020/07/12/658.%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E6%95%B0/"/>
      <url>/2020/07/12/658.%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="找到K个最接近的元素"><a href="#找到K个最接近的元素" class="headerlink" title="找到K个最接近的元素"></a>找到K个最接近的元素</h1><p>给定一个排序好的数组，两个整数 <code>k</code> 和 <code>x</code>，从数组中找到最靠近 <code>x</code>（两数之差最小）的 <code>k</code> 个数。返回的结果必须要是按升序排好的。如果有两个数与 <code>x</code> 的差值一样，优先选择数值较小的那个数。</p><p><strong>示例 1:</strong></p><pre><code>输入: [1,2,3,4,5], k=4, x=3输出: [1,2,3,4]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [1,2,3,4,5], k=4, x=-1输出: [1,2,3,4]</code></pre><p><strong>说明:</strong></p><ol><li>k 的值为正数，且总是小于给定排序数组的长度。</li><li>数组不为空，且长度不超过 104</li><li>数组里的每个元素与 x 的绝对值不超过 104</li></ol><p><strong>更新(2017/9/19):</strong><br>这个参数 <em>arr</em> 已经被改变为一个<strong>整数数组</strong>（而不是整数列表）。 <strong>请重新加载代码定义以获取最新更改。</strong></p><hr><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本文参考这位大佬的题解[方法二： 二分查找最优区间的左边界]</p><p><a href="https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/</a></p><p>此问题转换为 <strong>查找最优区间的左边界</strong></p><pre><code>输入: [1,2,3,4,5], k=4, x=3输出: [1,2,3,4]</code></pre><p>例如这个示例，<strong>k为4</strong>，即区间的长度为4，这个区间可能是 <strong>[1,2,3,4] 和 [2,3,4,5]</strong>，所以最左边界元素的区间在 <strong>[0, 1]</strong>范围内</p><p>也就是说，<strong>最优区间的左边界</strong>在<strong>[0, length-k]</strong>这个区间中</p><p>那么，现在的问题就转换成了 在<strong>[0, length-k]</strong>区间内找到一个元素，这个元素是<strong>最优区间的左边界</strong></p><p>来整理一下题目的条件：</p><blockquote><p><strong>x</strong> ： 目标值</p><p><strong>k</strong> ： 结果数组内的元素个数</p></blockquote><ol><li>最优区间内的每个元素与 <strong>x</strong> 的差值都是最小的</li><li>找到的最优区间必须升序排列的</li></ol><h3 id="步骤解析"><a href="#步骤解析" class="headerlink" title="步骤解析"></a>步骤解析</h3><p>1.找到左边界元素所在区间</p><blockquote><p>这个很简单，就是[0, length-k]</p></blockquote><p>2.区间内的中位数(<strong>x - arr[mid]</strong>与<strong>arr[mid+k] - x</strong>进行比较)</p><blockquote><p>首先明白此时<strong>mid</strong>和<strong>mid+k</strong>各自代表的意义是什么？</p><p>mid：“最优区间”的左边界，可能当前不是最优区间，待进一步二分查找</p><p>mid+k：“最优区间”右边界的<strong>右边一位</strong></p><p>1) 如果<strong>x - arr[mid] &gt; arr[mid+k] - x</strong>,说明什么？</p><ul><li>说明 <strong>x</strong> 更应该靠近<strong>arr[mid+k]</strong>一些， 即<strong>arr[mid, mid+k]</strong>这个区间整体向右滑动，才可能成为 <strong>最优区间</strong></li><li>要使得这个区间<strong>向右滑动</strong>，也就是将这个区间的<strong>左边界右移</strong>。</li><li>回到二分查找，就是向右收缩 =&gt; <strong>left = mid + 1</strong></li></ul><p>2) 如果<strong>x - arr[mid] &lt; arr[mid+k] - x</strong>,说明什么？</p><ul><li>说明 <strong>mid + k位置 及 右边所有的元素</strong> 都不符合最优区间（因为是升序的），当前的“最优区间”为 arr[mid, mid + k]。但是mid之前可能存在有元素哦，所以mid之前的元素应该继续进行判断</li><li>mid之前的元素可能有更优的，就是区间<strong>可能向左移动</strong>，也可能当前mid就是最优区间的左边界（不移动）</li><li>为了找到更合适的mid，所以应该收缩[0, length-k]这个区间，因为是去找mid及mid之前的元素，所以是向左收缩，即 right = mid</li><li>为什么是right = mid，而不是right = mid - 1？因为mid这个位置的值，可能刚好就是<strong>最优区间的左边界</strong>，如果mid-1就错过了</li></ul><p>3) 如果<strong>x - arr[mid] = arr[mid+k] - x</strong>,说明什么？</p><ul><li>仔细想想，这两者差值相等的情况是和 <strong>2)</strong> 的情况一致</li></ul></blockquote><p>3.经过左右边界的不断收缩，最终找到的一个元素，这个元素就是 <strong>最优区间的左边界</strong>,即可求出答案</p><p><img src="https://s1.ax1x.com/2020/07/08/UVsOsg.gif" alt="程序执行动图"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="python">class Solution:    def findClosestElements(self, arr: List[int], k: int, x: int) -&gt; List[int]:        left, right = 0, len(arr) - k # 确定最优区间的左边界所在区间范围        while left &lt; right:            mid = (left + right) &gt;&gt; 1 # 找到中位数            if x - arr[mid] &gt; arr[mid+k] - x: # 比较差值，收缩区间                left = mid + 1            elif x - arr[mid] &lt;= arr[mid+k] - x:                right = mid        return arr[left:left+k]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23.合并K个排序列表</title>
      <link href="/2020/07/12/23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8/"/>
      <url>/2020/07/12/23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例:</strong></p><p>输入:</p><pre><code>[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]</code></pre><p>输出: <strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</strong></p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists</a></p><p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><hr><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>此学习笔记，参考题解：</p><p>感谢！！</p><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/duo-tu-yan-shi-23-he-bing-kge-pai-xu-lian-biao-by-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/duo-tu-yan-shi-23-he-bing-kge-pai-xu-lian-biao-by-/</a></p><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/leetcode-23-he-bing-kge-pai-xu-lian-biao-by-powcai/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/leetcode-23-he-bing-kge-pai-xu-lian-biao-by-powcai/</a></p><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><blockquote><p>  依靠最小堆的特性，每次弹出必定是最小值</p></blockquote><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>步骤：</p><ol><li>将所有节点的加入到堆队列中</li><li>不断弹出，生成新的链表</li></ol><blockquote><p>  说明： 在python中，实例与实例之间不能直接使用 <code>&gt;</code>等比较运算符</p><p>  我们可以写一个魔术方法，使得〔ListNode〕之间可以大小比较</p><pre><code class="python">  def __lt__(self, other):      return self.val &lt; other.val  ListNode.__lt__ = __lt__</code></pre></blockquote><p>完整代码：</p><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        if not lists: return None        import heapq        queue = []        dummy = ListNode(-1)        def __lt__(self, other):            return self.val &lt; other.val        ListNode.__lt__ = __lt__        cur = dummy        # 将所有节点加入至堆队列中        for l in lists:            while l:                heapq.heappush(queue, l)                l = l.next        # 不断取出节点        while queue:            # 由于最小堆的特性，每次取出的节点都是最小的            node = heapq.heappop(queue)            cur.next = node            cur = cur.next        cur.next = None        return dummy.next</code></pre><p>空间复杂度： O(N)</p><h4 id="堆排序优化"><a href="#堆排序优化" class="headerlink" title="堆排序优化"></a>堆排序优化</h4><p>此方法是对上一方法的优化，在上面方法中是直接将所有的节点一股脑全部丢到堆队列中，这造成了空间的浪费。在此，可以将空间复杂度优化成<code>O(K)</code>，即链表的数量</p><p><img src="https://pic.leetcode-cn.com/a91253f60b46b4d804adff9d3af7fb54586018e173d480cf06f4530630f3eb8d-3.jpg" alt="演示图"></p><p>将每个链表的头结点，加入到堆队列即可，<strong>当此节点出队列时，立即判断此节点的指针域是否为空，不为空就表示后面还有节点，所以将后面的节点加入到堆队列中</strong>。如此一来，堆队列的空间大小就没有发生变换。</p><p>步骤：</p><ol><li>将所有链表的头节点加入到堆队列中</li><li>出队，将出来的节点连接到新节点上<code>dummy</code></li><li>检测刚出队的节点的指针域是否有效，有效则将下一个节点加入到堆队列中</li></ol><p>完整代码：</p><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        def __lt__(self, other):            return self.val &lt; other.val        ListNode.__lt__ = __lt__        if not lists:            return        import heapq        queue = []        dummy = ListNode(-1)        cur  = dummy        # 将所有的链表的头结点入队        for i in range(len(lists)):            head = lists[i]            if head:                heapq.heappush(queue, head)        # 从堆队列中弹出并检测是否还有下一个节点，有则加入到堆队列中        while queue:            node = heapq.heappop(queue)            cur.next = node            cur = cur.next            # 下一个节点是否有效            if node.next:                heapq.heappush(queue, node.next)        cur.next = None        return dummy.next</code></pre><h3 id="两两合并"><a href="#两两合并" class="headerlink" title="两两合并"></a>两两合并</h3><p>[简单]合并两个有序链表：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><p>之前做过一道题，实现两个有序链表的合并</p><p>本题是多个有序链表的合并，所以自然可以使用使用两两合并，合并到最后即成为一个有序链表</p><p>完整代码：</p><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        dummy = ListNode(float(&#39;-inf&#39;))        cur = dummy        for i in range(len(lists)):            cur = self.mergeTwoLists(cur, lists[i])        return dummy.next    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        dummy = ListNode(-1)        cur = dummy        while l1 and l2:            if l1.val &lt; l2.val:                cur.next = l1                l1 = l1.next            else:                cur.next = l2                l2 = l2.next            cur = cur.next        cur.next = l1 if l1 else l2        return dummy.next</code></pre><p>然而，效率极低</p><p><img src="https://s1.ax1x.com/2020/07/10/UK53rQ.png" alt="UK53rQ.png"></p><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>在排序算法中，一个〔归并排序〕</p><blockquote><p>  将无序的序列分解成一个一个，然后按有序方式组合</p></blockquote><p>归并排序中的 <strong>分治思想</strong> 可以在此题应用到</p><p><img src="https://pic.leetcode-cn.com/88d261465f1f21288dd23cef2f059297f5d053fc19805458a47ae1b05f3c0703-6.jpg" alt="6.jpg"></p><p>按照归并排序的案例或上图的演示，我们首先将 <strong>lists</strong> 中的链表一分再分， 然后按照大小关系一一合并</p><p>步骤：</p><ol><li>将 <strong>lists</strong> 一分再分，分到不能再分为止</li><li>不断合并</li><li>最后得到完整的有序链表</li></ol><blockquote><p>  步骤描述只是大概，具体还是得根据代码来慢慢理解，所以一定要写注释！！！</p></blockquote><p>完整代码：</p><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        if not lists: return         return self.merge(0, len(lists)-1, lists)    def merge(self, left, right, lists):        &quot;&quot;&quot;将lists不断分割，这里的操作有点像二分法        通过不断的一分二，分到最小单位        &quot;&quot;&quot;        if left == right:            return lists[left]        mid = (left + right) &gt;&gt; 1        l1 = self.merge(left, mid, lists)        l2 = self.merge(mid+1, right, lists)        # 调用合并函数，将 l1 和 l2合并成新有序链表        return self.mergeTwoLists(l1, l2)    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        &quot;&quot;&quot;将两个链表合成一个有序链表&quot;&quot;&quot;        dummy = ListNode(-1)        cur = dummy        while l1 and l2:            if l1.val &lt; l2.val:                cur.next = l1                l1 = l1.next            else:                cur.next = l2                l2 = l2.next            cur = cur.next        cur.next = l1 if l1 else l2        return dummy.next</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
            <tag> 分治算法 </tag>
            
            <tag> 优先级队列 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
