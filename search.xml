<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[object Object]</title>
      <link href="/2020/07/08/%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E6%95%B0/"/>
      <url>/2020/07/08/%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="找到K个最接近的元素"><a href="#找到K个最接近的元素" class="headerlink" title="找到K个最接近的元素"></a>找到K个最接近的元素</h4><p>给定一个排序好的数组，两个整数 <code>k</code> 和 <code>x</code>，从数组中找到最靠近 <code>x</code>（两数之差最小）的 <code>k</code> 个数。返回的结果必须要是按升序排好的。如果有两个数与 <code>x</code> 的差值一样，优先选择数值较小的那个数。</p><p><strong>示例 1:</strong></p><pre><code>输入: [1,2,3,4,5], k=4, x=3输出: [1,2,3,4]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [1,2,3,4,5], k=4, x=-1输出: [1,2,3,4]</code></pre><p><strong>说明:</strong></p><ol><li>k 的值为正数，且总是小于给定排序数组的长度。</li><li>数组不为空，且长度不超过 104</li><li>数组里的每个元素与 x 的绝对值不超过 104</li></ol><p><strong>更新(2017/9/19):</strong><br>这个参数 <em>arr</em> 已经被改变为一个<strong>整数数组</strong>（而不是整数列表）。 <strong>请重新加载代码定义以获取最新更改。</strong></p><hr><p>问题可以转换为 <strong>寻找最左边界</strong></p><pre><code>输入: [1,2,3,4,5], k=4, x=3输出: [1,2,3,4]</code></pre><p>例如这个示例，<strong>k为4</strong>，则可能有 <strong>[1,2,3,4] &amp; [2,3,4,5]</strong>，所以最左边界的区间在 <strong>[0, 1]</strong></p><p>也就是说最左边界的区间是<strong>[0, length-k]</strong> (length是数组长度)</p><p>那么，现在的问题就转换成了 <strong>在这个区间内找到一个元素，使得满足题目条件</strong></p><p>来整理一下题目的条件：</p><blockquote><p><strong>x</strong> ： 目标值</p><p><strong>k</strong> ： 结果数组内的元素个数</p></blockquote><ol><li>找到的结果数组内的每个元素与 <strong>x</strong> 的差值都是最小的</li><li>找到的结果数组必须升序排列的</li></ol><p>程序执行动图</p><p><img src="https://s1.ax1x.com/2020/07/08/UVsOsg.gif" alt="UVsOsg.gif"></p><pre><code class="python">class Solution:    def findClosestElements(self, arr: List[int], k: int, x: int) -&gt; List[int]:        left, right = 0, len(arr) - k        while left &lt; right:            mid = (left + right) &gt;&gt; 1            if x - arr[mid] &gt; arr[mid+k] - x:                left = mid + 1            elif x - arr[mid] &lt;= arr[mid+k] - x:                right = mid        return arr[left:left+k]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找模板</title>
      <link href="/2020/07/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/07/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>最近又开始刷算法题，准备在这个暑假把算法练练。</p><p>本文模板均来自leetcode</p><p><a href="https://leetcode-cn.com/explore/learn/card/binary-search/" target="_blank" rel="noopener">https://leetcode-cn.com/explore/learn/card/binary-search/</a></p><h2 id="二分查找模板-1"><a href="#二分查找模板-1" class="headerlink" title="二分查找模板 #1"></a>二分查找模板 #1</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">def binarySearch(nums, target):    &quot;&quot;&quot;    :type nums: List[int]    :type target: int    :rtype: int    &quot;&quot;&quot;    if len(nums) == 0:        return -1    left, right = 0, len(nums) - 1    while left &lt;= right:        mid = (left + right) // 2        if nums[mid] == target:            return mid        elif nums[mid] &lt; target:            left = mid + 1        else:            right = mid - 1    # End Condition: left &gt; right    return -1</code></pre><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><blockquote><p>用于查找可以通过<em>访问数组中的单个索引</em>来确定的元素或条件。</p></blockquote><h2 id="二分查找模板-2"><a href="#二分查找模板-2" class="headerlink" title="二分查找模板 #2"></a>二分查找模板 #2</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">def binarySearch(nums, target):    &quot;&quot;&quot;    :type nums: List[int]    :type target: int    :rtype: int    &quot;&quot;&quot;    if len(nums) == 0:        return -1    left, right = 0, len(nums) # 注意right = len(nums)    while left &lt; right:        mid = (left + right) // 2        if nums[mid] == target:            return mid        elif nums[mid] &lt; target:            left = mid + 1        else:            right = mid    # Post-processing:    # End Condition: left == right    if left != len(nums) and nums[left] == target:        return left    return -1</code></pre><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><blockquote><p>模板 #2 是二分查找的高级模板。它用于查找需要<em>访问数组中*</em>当前索引及其直接右邻居索引***的元素或条件。</p></blockquote><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h4><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给定一个输入数组 <code>nums</code>，其中 <code>nums[i] ≠ nums[i+1]</code>，找到峰值元素并返回其索引。</p><p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code>。</p><p><strong>示例 1:</strong></p><pre><code>输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2；     或者返回索引 5， 其峰值元素为 6。</code></pre><p><strong>说明:</strong></p><p>你的解法应该是 <em>O</em>(<em>logN</em>) 时间复杂度的。</p><h2 id="二分查找模板-3"><a href="#二分查找模板-3" class="headerlink" title="二分查找模板 #3"></a>二分查找模板 #3</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">def binarySearch(nums, target):    &quot;&quot;&quot;    :type nums: List[int]    :type target: int    :rtype: int    &quot;&quot;&quot;    if len(nums) == 0:        return -1    left, right = 0, len(nums) - 1    while left + 1 &lt; right:        mid = (left + right) // 2        if nums[mid] == target:            return mid        elif nums[mid] &lt; target:            left = mid        else:            right = mid    # Post-processing:    # End Condition: left + 1 == right    if nums[left] == target: return left    if nums[right] == target: return right    return -1</code></pre><h3 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h3><blockquote><p>模板 #3 是二分查找的另一种独特形式。 它用于搜索需要<em>访问当前索引及其在数组中的直接左右邻居索引</em>的元素或条件。</p></blockquote><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3>]]></content>
      
      
      <categories>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
